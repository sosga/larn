#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	data.c
#	display.c
#	global.c
#	nap.c
# This archive created: Wed Aug  6 14:58:57 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'data.c'" '(31123 characters)'
if test -f 'data.c'
then
	echo shar: will not over-write existing file "'data.c'"
else
cat << \SHAR_EOF > 'data.c'
/*	data.c		Larn is copyrighted 1986 by Noah Morgan. */
#define NODEFS
#include "header.h"

/*
	class[c[LEVEL]-1] gives the correct name of the players experience level
 */
static char aa1[] =	" mighty evil master";
static char aa2[] =	"apprentice demi-god";
static char aa3[] =	"  minor demi-god   ";
static char aa4[] =	"  major demi-god   ";
static char aa5[] =	"    minor deity    ";
static char aa6[] =	"    major deity    "; 
static char aa7[] =	"  novice guardian  ";
static char aa8[] =	"apprentice guardian";
static char aa9[] =	"    The Creator    ";
char *class[]=
{	"  novice explorer  ", "apprentice explorer", " practiced explorer",/*  -3*/
	"   expert explorer ", "  novice adventurer", "     adventurer    ",/*  -6*/
	"apprentice conjurer", "     conjurer      ", "  master conjurer  ",/*  -9*/
	"  apprentice mage  ", "        mage       ", "  experienced mage ",/* -12*/
	"     master mage   ", " apprentice warlord", "   novice warlord  ",/* -15*/
	"   expert warlord  ", "   master warlord  ", " apprentice gorgon ",/* -18*/
	"       gorgon      ", "  practiced gorgon ", "   master gorgon   ",/* -21*/
	"    demi-gorgon    ", "    evil master    ", " great evil master ",/* -24*/
	  aa1       ,   aa1       ,   aa1       ,/* -27*/
	  aa1       ,   aa1       ,   aa1       ,/* -30*/
	  aa1       ,   aa1       ,   aa1       ,/* -33*/
	  aa1       ,   aa1       ,   aa1       ,/* -36*/
	  aa1       ,   aa1       ,   aa1       ,/* -39*/
	  aa2       ,   aa2       ,   aa2       ,/* -42*/
	  aa2       ,   aa2       ,   aa2       ,/* -45*/
	  aa2       ,   aa2       ,   aa2       ,/* -48*/
	  aa3       ,   aa3       ,   aa3       ,/* -51*/
	  aa3       ,   aa3       ,   aa3       ,/* -54*/
	  aa3       ,   aa3       ,   aa3       ,/* -57*/
	  aa4       ,   aa4       ,   aa4       ,/* -60*/
	  aa4       ,   aa4       ,   aa4       ,/* -63*/
	  aa4       ,   aa4       ,   aa4       ,/* -66*/
	  aa5       ,   aa5       ,   aa5       ,/* -69*/
	  aa5       ,   aa5       ,   aa5       ,/* -72*/
	  aa5       ,   aa5       ,   aa5       ,/* -75*/
	  aa6       ,   aa6       ,   aa6       ,/* -78*/
	  aa6       ,   aa6       ,   aa6       ,/* -81*/
	  aa6       ,   aa6       ,   aa6       ,/* -84*/
	  aa7       ,   aa7       ,   aa7       ,/* -87*/
	  aa8       ,   aa8       ,   aa8       ,/* -90*/
	  aa8       ,   aa8       ,   aa8       ,/* -93*/
	"  earth guardian   ", "   air guardian    ", "   fire guardian   ",/* -96*/
	"  water guardian   ", "  time guardian    ", " ethereal guardian ",/* -99*/
	  aa9       ,   aa9       ,   aa9       ,/* -102*/
};

/*
	table of experience needed to be a certain level of player
	skill[c[LEVEL]] is the experience required to attain the next level
 */
#define MEG 1000000
long skill[] = {
0, 10, 20, 40, 80, 160, 320, 640, 1280, 2560, 5120,                  /*  1-11 */
10240, 20480, 40960, 100000, 200000, 400000, 700000, 1*MEG,          /* 12-19 */
2*MEG,3*MEG,4*MEG,5*MEG,6*MEG,8*MEG,10*MEG,                          /* 20-26 */
12*MEG,14*MEG,16*MEG,18*MEG,20*MEG,22*MEG,24*MEG,26*MEG,28*MEG,      /* 27-35 */
30*MEG,32*MEG,34*MEG,36*MEG,38*MEG,40*MEG,42*MEG,44*MEG,46*MEG,      /* 36-44 */
48*MEG,50*MEG,52*MEG,54*MEG,56*MEG,58*MEG,60*MEG,62*MEG,64*MEG,      /* 45-53 */
66*MEG,68*MEG,70*MEG,72*MEG,74*MEG,76*MEG,78*MEG,80*MEG,82*MEG,      /* 54-62 */
84*MEG,86*MEG,88*MEG,90*MEG,92*MEG,94*MEG,96*MEG,98*MEG,100*MEG,     /* 63-71 */
105*MEG,110*MEG,115*MEG,120*MEG, 125*MEG, 130*MEG, 135*MEG, 140*MEG, /* 72-79 */
145*MEG,150*MEG,155*MEG,160*MEG, 165*MEG, 170*MEG, 175*MEG, 180*MEG, /* 80-87 */
185*MEG,190*MEG,195*MEG,200*MEG, 210*MEG, 220*MEG, 230*MEG, 240*MEG, /* 88-95 */
250*MEG,260*MEG,270*MEG,280*MEG, 290*MEG, 300*MEG                    /* 96-101*/
};
#undef MEG

char *lpbuf,*lpnt,*inbuffer,*lpend;	/* input/output pointers to the buffers */
struct cel *cell;	/*	pointer to the dungeon storage	*/
short hitp[MAXX][MAXY];		/*	monster hp on level		*/
short iarg[MAXX][MAXY];	/*	arg for the item array	*/
char item[MAXX][MAXY];	/*	objects in maze if any	*/
char know[MAXX][MAXY];	/*	1 or 0 if here before	*/
char mitem[MAXX][MAXY];	/*	monster item array 		*/
char moved[MAXX][MAXY];	/*	monster movement flags  */
char stealth[MAXX][MAXY];	/*  0=sleeping 1=awake monst*/
char iven[26];			/*	inventory for player			*/
short ivenarg[26];		/*	inventory for player			*/
char lastmonst[40];		/*	this has the name of the current monster	*/
char beenhere[MAXLEVEL+MAXVLEVEL]=0;	/*  1 if have been on this level */
char VERSION=VER;	/*	this is the present version # of the program	*/
char SUBVERSION=SUBVER;
char nosignal=0;	/* set to 1 to disable the signals from doing anything */
char predostuff=0;	/*  2 means that the trap handling routines must do a
						showplayer() after a trap.  0 means don't showplayer()
						0 - we are in create player screen
						1 - we are in welcome screen
						2 - we are in the normal game	*/
char loginname[20];		/* players login name */
char logname[LOGNAMESIZE];	/* players name storage for scoring				*/
char sex=1;				/*  default is a man  0=woman						*/
char boldon=1;			/*  1=bold objects  0=inverse objects				*/
char ckpflag=0;			/*	1 if want checkpointing of game, 0 otherwise	*/
char cheat=0;			/*	1 if the player has fudged save file			*/
char level=0;			/*  cavelevel player is on = c[CAVELEVEL]			*/
char wizard=0;			/*	the wizard mode flag							*/
short lastnum=0;		/* the number of the monster last hitting player 	*/
short hitflag=0;		/*	flag for if player has been hit when running 	*/
short hit2flag=0;		/*	flag for if player has been hit when running 	*/
short hit3flag=0;		/*	flag for if player has been hit flush input 	*/
short playerx,playery;	/*	the room on the present level of the player		*/
short lastpx,lastpy;	/*	0 --- MAXX-1  or  0 --- MAXY-1					*/
short oldx,oldy;
short lasthx=0,lasthy=0;	/* location of monster last hit by player		*/
short nobeep=0;			/* true if program is not to beep  					*/
unsigned long randx=33601;	/*	the random number seed						*/
long initialtime=0;			/* time playing began 							*/
long gtime=0;				/*	the clock for the game						*/
long outstanding_taxes=0;	/* present tax bill from score file 			*/
long c[100],cbak[100];		/*	the character description arrays			*/
int enable_scroll=0;		/* constant for enabled/disabled scrolling regn */
char aborted[] = " aborted";
struct sphere *spheres=0; /*pointer to linked list for spheres of annihilation*/
char *levelname[]=
{ " H"," 1"," 2"," 3"," 4"," 5"," 6"," 7"," 8"," 9","10","V1","V2","V3" };

char objnamelist[]=" ATOP%^F&^+M=%^$$f*OD#~][[)))(((||||||||{?!BC}o:@.<<<<EVV))([[]]](^ [H*** ^^ S tsTLc............................................";
char monstnamelist[]=" BGHJKOScjtAELNQRZabhiCTYdegmvzFWflorXV pqsyUkMwDDPxnDDuD        ...............................................................";
char *objectname[]=
{ 0,"a holy altar","a handsome jewel encrusted throne","the orb","a pit",
  "a staircase leading upwards","an elevator going up","a bubbling fountain",
  "a great marble statue","a teleport trap","the college of Larn",
  "a mirror","the DND store","a staircase going down","an elevator going down",
  "the bank of Larn","the 5th branch of the Bank of Larn",
  "a dead fountain","gold","an open door","a closed door",
  "a wall","The Eye of Larn","plate mail","chain mail","leather armor",
  "a sword of slashing","Bessman's flailing hammer","a sunsword",
  "a two handed sword","a spear","a dagger",
  "ring of extra regeneration","a ring of regeneration","a ring of protection",
  "an energy ring","a ring of dexterity","a ring of strength",
  "a ring of cleverness","a ring of increase damage","a belt of striking",
  "a magic scroll","a magic potion","a book","a chest",
  "an amulet of invisibility","an orb of dragon slaying",
  "a scarab of negate spirit","a cube of undead control",
  "device of theft prevention","a brilliant diamond","a ruby",
  "an enchanting emerald","a sparkling sapphire","the dungeon entrance",
  "a volcanic shaft leaning downward","the base of a volcanic shaft",
  "a battle axe","a longsword","a flail","ring mail","studded leather armor",
  "splint mail","plate armor","stainless plate armor","a lance of death",
  "an arrow trap","an arrow trap","a shield","your home",
  "gold","gold","gold","a dart trap",
  "a dart trap","a trapdoor","a trapdoor","the local trading post",
  "a teleport trap", "a massive throne",
  "a sphere of annihilation","a handsome jewel encrusted throne",
  "the Larn Revenue Service","a fortune cookie","","","","","","",
  "","","","","","","","","","","","","","","","","","","",""
 };


/*
 *	for the monster data
 *
 *	array to do rnd() to create monsters <= a given level
 */
char monstlevel[] = { 5, 11, 17, 22, 27, 33, 39, 42, 46, 50, 53, 56, 59 };

struct monst monster[] = {
/*	NAME			LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
----------------------------------------------------------------- */
{ "",				0,	0,	0,	0,	0,	 0,  3,   0,	0,	0	},
{ "bat",			1,	0,	1,	0,	0,	 0,  3,   0,	1,	1	},
{ "gnome",			1,	10,	1,	0,	0,	 0,  8,  30,	2,	2	},
{ "hobgoblin",		1,	14,	2,	0,	0,	 0,  5,  25,	3,	2	},
{ "jackal",			1,	17,	1,	0,	0,	 0,  4,   0,	1,	1	},
{ "kobold",			1,	20,	1,	0,	0,	 0,  7,  10,	1,	1	},

{ "orc",			2,	12,	1,	0,	0,	 0,  9,  40,	4,	2	},
{ "snake",			2,	15,	1,	0,	0,	 0,  3,   0,	3,	1	},
{ "giant centipede",2,	14,	0,	4,	0,	 0,  3,   0,	1,	2	},
{ "jaculi",			2,	20,	1,	0,	0,	 0,  3,   0,	2,	1	},
{ "troglodyte",		2,	10,	2,	0,	0,	 0,  5,  80,	4,	3	},
{ "giant ant",		2,	8,	1,	4,	0,	 0,  4,   0,	5,	5	},

/*	NAME			LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
----------------------------------------------------------------- */

{ "floating eye",	3,	8,	1,	0,	0,	 0,  3,   0,	 5,	 2	},
{ "leprechaun",		3,	3,	0,	8,	0,	 0,  3,1500,    13,	45	},
{ "nymph",			3,	3,	0,	14,	0,	 0,  9,   0,	18,	45	},
{ "quasit",			3,	5,	3,	0,	0,	 0,  3,   0,	10,	15	},
{ "rust monster",	3,	4,	0,	1,	0,	 0,  3,   0,	18,	25	},
{ "zombie",			3,	12,	2,	0,	0,	 0,  3,   0,	 6,	 7	},

{ "assassin bug",	4,	9,	3,	0,	0,	 0,  3,   0,	20,	15	},
{ "bugbear",		4,	5,	4,	15,	0,	 0,  5,  40,	20,	35	},
{ "hell hound",		4,	5,	2,	2,	0,	 0,  6,   0,	16,	35	},
{ "ice lizard",		4,	11,	2,	10,	0,	 0,  6,  50,	16,	25	},
{ "centaur",		4,	6,	4,	0,	0,	 0, 10,  40,	24,	45	},

/*	NAME			LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
----------------------------------------------------------------- */

{ "troll",			5,	4,	5,	0,	0,	 0,  9,  80,	50,	300	},
{ "yeti",			5,	6,	4,	0,	0,	 0,  5,  50, 	35,	100	},
{ "white dragon",	5,	2,	4,	5,	0,	 0, 16, 500,	55,	1000},
{ "elf",			5,	8,	1,	0,	0,	 0, 15,  50,	22,	35	},
{ "gelatinous cube",5,	9,	1,	0,	0,	 0,  3,   0,	22,	45	},

{ "metamorph",		6,	7,	3,	0,	0,	 0,  3,  0,		30,	40	},
{ "vortex",			6,	4,	3,	0,	0,	 0,  3,  0,		30,	55	},
{ "ziller",			6,	15,	3,	0,	0,	 0,  3,  0,		30,	35	},
{ "violet fungi",	6,	12,	3,	0,	0,	 0,  3,  0,	 	38,	100	},
{ "wraith",			6,	3,	1,	6,	0,	 0,  3,  0,		30,	325	},
{ "forvalaka",		6,	2,	5,	0,	0,	 0,  7,  0,		50,	280	},

/*	NAME			LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
----------------------------------------------------------------- */

{ "lama nobe",		7,	7,	3,	0,	0,	 0,  6,  0,		35,	80	},
{ "osequip",		7,	4,	3,	16,	0,	 0,  4,  0,		35,	100	},
{ "rothe",			7,	15,	5,	0,	0,	 0,  3,  100,	50,	250	},
{ "xorn",			7,	0,	6,	0,	0,	 0, 13,  0,		60,	300	},
{ "vampire",		7,	3,	4,	6,	0,	 0, 17,  0,		50,	1000},
{ "invisible stalker",7,3,	6,	0,	0,	 0,  5,  0,		50,	350	},

{ "poltergeist",	8,	1,	4,	0,	0,	 0,  3,  0,		50,	450	},
{ "disenchantress",	8,	3,	0,	9,	0,	 0,  3,  0,		50,	500	},
{ "shambling mound",8,	2,	5,	0,	0,	 0,  6,  0,		45,	400	},
{ "yellow mold",	8,	12,	4,	0,	0,	 0,  3,  0,		35,	250	},
{ "umber hulk",		8,	3,	7,	11,	0,	 0, 14,  0,		65,	600	},

/*	NAME			LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
----------------------------------------------------------------- */

{ "gnome king",		9,	-1,	10,	0,	0,	 0, 18,  2000,	100,3000	},
{ "mimic",			9,	 5,	6,	0,	0,	 0,  8,  0,		55,	99		},
{ "water lord",		9, -10,	15,	7,	0,	 0, 20,  0,		150,15000	},
{ "bronze dragon",	9,	 2,	9,	3,	0,	 0, 16,  300,	80, 4000	},
{ "green dragon",	9,	 3,	8,	10,	0,	 0, 15,  200,	70, 2500	},
{ "purple worm",	9,	-1,	11,	0,	0,	 0,  3,  100,	120,15000	},
{ "xvart",			9,	-2,	12,	0,	0,	 0, 13,  0,		90,	1000	},

{ "spirit naga",	10, -20,12,	12,	0,	 0, 23,  0,		95, 20000	},
{ "silver dragon",	10,	-1,	12,	3,	0,	 0, 20,  700,	100,10000	},
{ "platinum dragon",10,	-5,	15,	13,	0,	 0, 22,  1000,	130,24000	},
{ "green urchin",	10,	-3,	12,	0,	0,	 0,  3,  0,		85, 5000	},
{ "red dragon",		10,	-2,	13,	3,	0,	 0, 19,  800,	110,14000	},

{ "type I demon lord",	12,-30,	18,	0,	 0,  0, 20,	0,	140,50000	},
{ "type II demon lord",	13,-30,	18,	0,	 0,  0, 21,	0,	160,75000	},
{ "type III demon lord",14,-30,	18,	0,	 0,  0, 22,	0,	180,100000	},
{ "type IV demon lord",	15,-35,	20,	0,	 0,  0, 23,	0,	200,125000	},
{ "type V demon lord",	16,-40,	22,	0,	 0,  0, 24,	0,	220,150000	},
{ "type VI demon lord",	17,-45,	24,	0,	 0,  0, 25,	0,	240,175000	},
{ "type VII demon lord",18,-70,	27,	6,	 0,  0, 26,	0,	260,200000	},
{ "demon prince",		25,-127,30,	6,	 0,  0, 28,	0,	345,300000	}

/*	NAME				LV	AC	DAM	ATT	DEF	GEN INT GOLD	HP	EXP
--------------------------------------------------------------------- */
 };

/*	name array for scrolls		*/

char *scrollname[] = {
"\0enchant armor",
"\0enchant weapon",
"\0enlightenment",
"\0blank paper",
"\0create monster",
"\0create artifact",
"\0aggravate monsters",
"\0time warp",
"\0teleportation",
"\0expanded awareness",
"\0haste monsters",
"\0monster healing",
"\0spirit protection",
"\0undead protection",
"\0stealth",
"\0magic mapping",
"\0hold monsters",
"\0gem perfection",
"\0spell extension",
"\0identify",
"\0remove curse",
"\0annihilation",
"\0pulverization",
"\0life protection",
"\0 ",
"\0 ",
"\0 ",
"\0 "
 };

/*	name array for magic potions	*/
char *potionname[] = {
"\0sleep",
"\0healing",
"\0raise level",
"\0increase ability",
"\0wisdom",
"\0strength",
"\0raise charisma",
"\0dizziness",
"\0learning",
"\0gold detection",
"\0monster detection",
"\0forgetfulness",
"\0water",
"\0blindness",
"\0confusion",
"\0heroism",
"\0sturdiness",
"\0giant strength",
"\0fire resistance",
"\0treasure finding",
"\0instant healing",
" cure dianthroritis",
"\0poison",
"\0see invisible",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 ",
"\0 "
 };


/*
	spell data
 */
char spelknow[SPNUM]=0;
char splev[] = { 1, 4, 9, 14, 18, 22, 26, 29, 32, 35, 37, 37, 37, 37, 37 };

char *spelcode[]={
	"pro",	"mle",	"dex",	"sle",	"chm",	"ssp",
	"web",	"str",	"enl",	"hel",	"cbl",	"cre",	"pha",	"inv",
	"bal",	"cld",	"ply",	"can",	"has",	"ckl",	"vpr",
	"dry",	"lit",	"drl",	"glo",	"flo",	"fgr",
	"sca",	"hld",	"stp",	"tel",	"mfi", /* 31 */
	"sph",	"gen",	"sum",	"wtw",	"alt",	"per"
 };

char *spelname[]={
	"protection",				"magic missile",		"dexterity",
	"sleep",					"charm monster",		"sonic spear",

	"web",						"strength",				"enlightenment",
	"healing",					"cure blindness",		"create monster",
	"phantasmal forces",		"invisibility",

	"fireball",					"cold",					"polymorph",
	"cancellation",				"haste self",			"cloud kill",
	"vaporize rock",

	"dehydration",				"lightning",			"drain life",
	"invulnerability",			"flood",				"finger of death",

	"scare monster",			"hold monster",			"time stop",
	"teleport away",			"magic fire",

	"sphere of annihilation",	"genocide",				"summon demon",
	"walk through walls",		"alter reality",		"permanence",
	""
 };

char *speldescript[]={
/* 1 */
	"generates a +2 protection field",
	"creates and hurls a magic missile equivalent to a + 1 magic arrow",
	"adds +2 to the casters dexterity",
	"causes some monsters to go to sleep",
	"some monsters may be awed at your magnificence",
	"causes your hands to emit a screeching sound toward what they point",
/* 7 */
	"causes strands of sticky thread to entangle an enemy",
	"adds +2 to the casters strength for a short term",
	"the caster becomes aware of things around him",
	"restores some hp to the caster",
	"restores sight to one so unfortunate as to be blinded",
	"creates a monster near the caster appropriate for the location",
	"creates illusions, and if believed, monsters die",
	"the caster becomes invisible",
/* 15 */
	"makes a ball of fire that burns on what it hits",
	"sends forth a cone of cold which freezes what it touches",
	"you can find out what this does for yourself",
	"negates the ability of a monster to use his special abilities",
	"speeds up the casters movements",
	"creates a fog of poisonous gas which kills all that is within it",
	"this changes rock to air",
/* 22 */
	"dries up water in the immediate vicinity",
	"you finger will emit a lightning bolt when this spell is cast",
	"subtracts hit points from both you and a monster",
	"this globe helps to protect the player from physical attack",
	"this creates an avalanche of H2O to flood the immediate chamber",
	"this is a holy spell and calls upon your god to back you up",
/* 28 */
	"terrifies the monster so that hopefully he wont hit the magic user",
	"the monster is frozen in his tracks if this is successful",
	"all movement in the caverns ceases for a limited duration",
	"moves a particular monster around in the dungeon (hopefully away from you)",
	"this causes a curtain of fire to appear all around you",
/* 33 */
	"anything caught in this sphere is instantly killed.  Warning -- dangerous",
	"eliminates a species of monster from the game -- use sparingly",
	"summons a demon who hopefully helps you out",
	"allows the player to walk through walls for a short period of time",
	"god only knows what this will do",
	"makes a character spell permanent, i. e. protection, strength, etc.",
	""
 };

char spelweird[MAXMONST+8][SPNUM] = {
/*                      p m d s c s    w s e h c c p i    b c p c h c v    d l d g f f    s h s t m    s g s w a p */
/*                      r l e l h s    e t n e b r h n    a l l a a k p    r i r l l g    c l t e f    p e u t l e */
/*                      o e x e m p    b r l l l e a v    l d y n s l r    y t l o o r    a d p l i    h n m w t r */
	

/*            bat */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*          gnome */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*      hobgoblin */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         jackal */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         kobold */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*            orc */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   4,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*          snake */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*giant centipede */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         jaculi */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     troglodyte */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*      giant ant */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*   floating eye */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     leprechaun */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*          nymph */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         quasit */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*   rust monster */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   4,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         zombie */ {  0,0,0,8,0,4,   0,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   4,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*   assassin bug */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*        bugbear */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     hell hound */ {  0,6,0,0,0,0,   12,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*     ice lizard */ {  0,0,0,0,0,0,   11,0,0,0,0,0,0,0,  0,15,0,0,0,0,0,  0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*        centaur */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*          troll */ {  0,7,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   4,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*           yeti */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,15,0,0,0,0,0,  0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*   white dragon */ {  0,0,0,0,0,0,   0,0,0,0,0,0,14,0,  0,15,0,0,0,0,0,  4,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*            elf */ {  0,0,0,0,0,0,   0,0,0,0,0,0,14,5,  0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*gelatinous cube */ {  0,0,0,0,0,0,   2,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   0,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*      metamorph */ {  0,13,0,0,0,0,  2,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   4,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         vortex */ {  0,13,0,0,0,10, 1,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         ziller */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*   violet fungi */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*         wraith */ {  0,0,0,8,0,4,   0,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   4,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*      forvalaka */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*      lama nobe */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*        osequip */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*          rothe */ {  0,7,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*           xorn */ {  0,7,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   4,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*        vampire */ {  0,0,0,8,0,4,   0,0,0,0,0,0,0,0,   0,0,0,0,0,4,0,   0,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*invisible staker*/ {  0,0,0,0,0,0,   1,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*    poltergeist */ {  0,13,0,8,0,4,  1,0,0,0,0,0,0,0,   0,4,0,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   0,0,0,0,0,0 },

/* disenchantress */ {  0,0,0,8,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*shambling mound */ {  0,0,0,0,0,10,  0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*    yellow mold */ {  0,0,0,8,0,0,   1,0,0,0,0,0,4,0,   0,0,0,0,0,4,0,   0,0,0,0,0,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     umber hulk */ {  0,7,0,0,0,0,   0,0,0,0,0,0,0,5,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     gnome king */ {  0,7,0,0,3,0,   0,0,0,0,0,0,0,5,   0,0,9,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*          mimic */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     water lord */ {  0,13,0,8,3,4,  1,0,0,0,0,0,0,0,   0,0,9,0,0,4,0,   0,0,0,0,16,4,  0,0,0,0,0,   0,0,0,0,0,0 },
/*  bronze dragon */ {  0,7,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*   green dragon */ {  0,7,0,0,0,0,   11,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*    purple worm */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*          xvart */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*    spirit naga */ {  0,13,0,8,3,4,  1,0,0,0,0,0,0,5,   0,4,9,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   0,0,0,0,0,0 },
/*  silver dragon */ {  0,6,0,9,0,0,   12,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*platinum dragon */ {  0,7,0,9,0,0,   11,0,0,0,0,0,14,0, 0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*   green urchin */ {  0,0,0,0,0,0,   0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },
/*     red dragon */ {  0,6,0,0,0,0,   12,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,   0,0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0 },

/*                      p m d s c s    w s e h c c p i    b c p c h c v    d l d g f f    s h s t m    s g s w a p */
/*                      r l e l h s    e t n e b r h n    a l l a a k p    r i r l l g    c l t e f    p e u t l e */
/*                      o e x e m p    b r l l l e a v    l d y n s l r    y t l o o r    a d p l i    h n m w t r */

/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*     demon lord */ {  0,7,0,4,3,0,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   0,0,0,0,0,   9,0,0,0,0,0 },
/*   demon prince */ {  0,7,0,4,3,9,   1,0,0,0,0,0,14,5,  0,0,4,0,0,4,0,   4,0,0,0,4,4,   4,0,0,0,4,   9,0,0,0,0,0 }

 };

char *spelmes[] = { "",
/*  1 */	"the web had no effect on the %s",
/*  2 */	"the %s changed shape to avoid the web",
/*  3 */	"the %s isn't afraid of you",
/*  4 */	"the %s isn't affected",
/*  5 */	"the %s can see you with his infravision",
/*  6 */	"the %s vaporizes your missile",
/*  7 */	"your missile bounces off the %s",
/*  8 */	"the %s doesn't sleep",
/*  9 */	"the %s resists",
/* 10 */	"the %s can't hear the noise",
/* 11 */	"the %s's tail cuts it free of the web",
/* 12 */	"the %s burns through the web",
/* 13 */	"your missiles pass right through the %s",
/* 14 */	"the %s sees through your illusions",
/* 15 */	"the %s loves the cold!",
/* 16 */	"the %s loves the water!"
 };

char to_lower[]= /* tolower[character] = lower case converted character */
    {
    0000,0001,0002,0003,0004,0005,0006,0007,0010,0011,0012,0013,0014,0015,0016,0017, /* NUL-SI*/
    0020,0021,0022,0023,0024,0025,0026,0027,0030,0031,0032,0033,0034,0035,0036,0037, /* DLE-US*/
    0040,0041,0042,0043,0044,0045,0046,0047,0050,0051,0052,0053,0054,0055,0056,0057, /* SP-/ */
    0060,0061,0062,0063,0064,0065,0066,0067,0070,0071,0072,0073,0074,0075,0076,0077, /* 0-? */
    0100,0141,0142,0143,0144,0145,0146,0147,0150,0151,0152,0153,0154,0155,0156,0157, /* @-O */
    0160,0161,0162,0163,0164,0165,0166,0167,0170,0171,0172,0133,0134,0135,0136,0137, /* P-_ */
    0140,0141,0142,0143,0144,0145,0146,0147,0150,0151,0152,0153,0154,0155,0156,0157, /* `-o */
    0160,0161,0162,0163,0164,0165,0166,0167,0170,0171,0172,0173,0174,0175,0176,0177, /* p-DEL */
    };

char to_upper[]= /* toupper[character] = upper case converted character */
    {
    0000,0001,0002,0003,0004,0005,0006,0007,0010,0011,0012,0013,0014,0015,0016,0017, /* NUL-SI*/
    0020,0021,0022,0023,0024,0025,0026,0027,0030,0031,0032,0033,0034,0035,0036,0037, /* DLE-US*/
    0040,0041,0042,0043,0044,0045,0046,0047,0050,0051,0052,0053,0054,0055,0056,0057, /* SP-/ */
    0060,0061,0062,0063,0064,0065,0066,0067,0070,0071,0072,0073,0074,0075,0076,0077, /* 0-? */
    0100,0101,0102,0103,0104,0105,0106,0107,0110,0111,0112,0113,0114,0115,0116,0117, /* @-O */
    0120,0121,0122,0123,0124,0125,0126,0127,0130,0131,0132,0133,0134,0135,0136,0137, /* P-_ */
    0140,0101,0102,0103,0104,0105,0106,0107,0110,0111,0112,0113,0114,0115,0116,0117, /* `-o */
    0120,0121,0122,0123,0124,0125,0126,0127,0130,0131,0132,0173,0174,0175,0176,0177, /* p-DEL */
    };

char is_digit[]=  /* isdigit[character] = TRUE || FALSE */
    {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* NUL-SI*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* DLE-US*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* SP-/ */
    1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, /* 0-? */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* @-O */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* P-_ */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* `-o */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* p-DEL */
    };

char is_alpha[]=  /* isalpha[character] = TRUE || FALSE */
    {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* NUL-SI*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* DLE-US*/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* SP-/ */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 0-? */
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* @-O */
    1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0, /* P-_ */
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* `-o */
    1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0, /* p-DEL */
    };

/*
 *	function to create scroll numbers with appropriate probability of 
 *	occurrence
 *
 *	0 - armor			1 - weapon		2 - enlightenment	3 - paper
 *	4 - create monster	5 - create item	6 - aggravate		7 - time warp
 *	8 - teleportation	9 - expanded awareness				10 - haste monst
 *	11 - heal monster	12 - spirit protection		13 - undead protection
 *	14 - stealth		15 - magic mapping			16 - hold monster
 *	17 - gem perfection 18 - spell extension		19 - identify
 *	20 - remove curse	21 - annihilation			22 - pulverization
 *  23 - life protection
 */
char scprob[]= { 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3,
	3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9,
	9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14,
	15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 20, 20, 21, 22,
	22, 22, 23 };

/*
 *	function to return a potion number created with appropriate probability
 *	of occurrence
 *
 *	0 - sleep				1 - healing					2 - raise level
 *	3 - increase ability	4 - gain wisdom				5 - gain strength
 *	6 - charismatic character	7 - dizziness			8 - learning
 *	9 - gold detection		10 - monster detection		11 - forgetfulness
 *	12 - water				13 - blindness				14 - confusion
 *	15 - heroism			16 - sturdiness				17 - giant strength
 *	18 - fire resistance	19 - treasure finding		20 - instant healing
 *	21 - cure dianthroritis	22 - poison					23 - see invisible
 */
char potprob[] = { 0, 0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 20, 22, 22, 23, 23 };

char nlpts[] = { 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7 };
char nch[] = { 0, 0, 0, 1, 1, 1, 2, 2, 3, 4 };
char nplt[] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 4 };
char ndgg[] = { 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 5 };
char nsw[] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 3 };

SHAR_EOF
if test 31123 -ne "`wc -c < 'data.c'`"
then
	echo shar: error transmitting "'data.c'" '(should have been 31123 characters)'
fi
fi
echo shar: extracting "'display.c'" '(11954 characters)'
if test -f 'display.c'
then
	echo shar: will not over-write existing file "'display.c'"
else
cat << \SHAR_EOF > 'display.c'
/*	display.c		Larn is copyrighted 1986 by Noah Morgan. */
#include "header.h"
#define makecode(_a,_b,_c) (((_a)<<16) + ((_b)<<8) + (_c))

static int minx,maxx,miny,maxy,k,m;
static char bot1f=0,bot2f=0,bot3f=0;
char always=0;
/*
	bottomline()

	now for the bottom line of the display
 */
bottomline()
	{	recalc();	bot1f=1;	}
bottomhp()
	{	bot2f=1;	}
bottomspell()
	{	bot3f=1;	}
bottomdo()
	{
	if (bot1f) { bot3f=bot1f=bot2f=0; bot_linex(); return; }
	if (bot2f) { bot2f=0; bot_hpx(); }
	if (bot3f) { bot3f=0; bot_spellx(); }
	}

bot_linex()
	{
	register int i;
	if (cbak[SPELLS] <= -50 || (always))
		{
		cursor( 1,18);
		if (c[SPELLMAX]>99)  lprintf("Spells:%3d(%3d)",(long)c[SPELLS],(long)c[SPELLMAX]);
						else lprintf("Spells:%3d(%2d) ",(long)c[SPELLS],(long)c[SPELLMAX]);
		lprintf(" AC: %-3d  WC: %-3d  Level",(long)c[AC],(long)c[WCLASS]);
		if (c[LEVEL]>99) lprintf("%3d",(long)c[LEVEL]);
					else lprintf(" %-2d",(long)c[LEVEL]);
		lprintf(" Exp: %-9d %s\n",(long)c[EXPERIENCE],class[c[LEVEL]-1]);
		lprintf("HP: %3d(%3d) STR=%-2d INT=%-2d ",
			(long)c[HP],(long)c[HPMAX],(long)(c[STRENGTH]+c[STREXTRA]),(long)c[INTELLIGENCE]);
		lprintf("WIS=%-2d CON=%-2d DEX=%-2d CHA=%-2d LV:",
			(long)c[WISDOM],(long)c[CONSTITUTION],(long)c[DEXTERITY],(long)c[CHARISMA]);

		if ((level==0) || (wizard))  c[TELEFLAG]=0;
		if (c[TELEFLAG])  lprcat(" ?");  else  lprcat(levelname[level]);
		lprintf("  Gold: %-6d",(long)c[GOLD]);
		always=1;  botside();
		c[TMP] = c[STRENGTH]+c[STREXTRA];
		for (i=0; i<100; i++) cbak[i]=c[i];
		return;
		}

	botsub(makecode(SPELLS,8,18),"%3d");
	if (c[SPELLMAX]>99)  botsub(makecode(SPELLMAX,12,18),"%3d)");
					else botsub(makecode(SPELLMAX,12,18),"%2d) ");
	botsub(makecode(HP,5,19),"%3d");
	botsub(makecode(HPMAX,9,19),"%3d");
	botsub(makecode(AC,21,18),"%-3d");
	botsub(makecode(WCLASS,30,18),"%-3d");
	botsub(makecode(EXPERIENCE,49,18),"%-9d");
	if (c[LEVEL] != cbak[LEVEL])
		{ cursor(59,18);	lprcat(class[c[LEVEL]-1]);  }
	if (c[LEVEL]>99) botsub(makecode(LEVEL,40,18),"%3d");
				else botsub(makecode(LEVEL,40,18)," %-2d");
	c[TMP] = c[STRENGTH]+c[STREXTRA];	botsub(makecode(TMP,18,19),"%-2d");
	botsub(makecode(INTELLIGENCE,25,19),"%-2d");
	botsub(makecode(WISDOM,32,19),"%-2d");
	botsub(makecode(CONSTITUTION,39,19),"%-2d");
	botsub(makecode(DEXTERITY,46,19),"%-2d");
	botsub(makecode(CHARISMA,53,19),"%-2d");
	if ((level != cbak[CAVELEVEL]) || (c[TELEFLAG] != cbak[TELEFLAG]))
		{
		if ((level==0) || (wizard))  c[TELEFLAG]=0;
		cbak[TELEFLAG] = c[TELEFLAG];
		cbak[CAVELEVEL] = level;	cursor(59,19);
		if (c[TELEFLAG])  lprcat(" ?");  else  lprcat(levelname[level]);
		}
	botsub(makecode(GOLD,69,19),"%-6d");
	botside();
	}

/*
	special subroutine to update only the gold number on the bottomlines
	called from ogold()
 */
bottomgold()
	{
	botsub(makecode(GOLD,69,19),"%-6d");
/*	botsub(GOLD,"%-6d",69,19); */
	}

/*
	special routine to update hp and level fields on bottom lines
	called in monster.c hitplayer() and spattack()
 */
bot_hpx()
	{
	if (c[EXPERIENCE] != cbak[EXPERIENCE])
		{
		recalc();	 bot_linex();
		}
	else botsub(makecode(HP,5,19),"%3d");	
	}

/*
	special routine to update number of spells called from regen()
 */
bot_spellx()
	{
	botsub(makecode(SPELLS,9,18),"%2d");
	}

/*
	common subroutine for a more economical bottomline()
 */
static struct bot_side_def
	{
	int typ;
	char *string;
	}
	bot_data[] =
	{
	STEALTH,"stealth",		UNDEADPRO,"undead pro",		SPIRITPRO,"spirit pro",
	CHARMCOUNT,"Charm",		TIMESTOP,"Time Stop",		HOLDMONST,"Hold Monst",
	GIANTSTR,"Giant Str",	FIRERESISTANCE,"Fire Resit", DEXCOUNT,"Dexterity",
	STRCOUNT,"Strength",	SCAREMONST,"Scare",			HASTESELF,"Haste Self",
	CANCELLATION,"Cancel",	INVISIBILITY,"Invisible",	ALTPRO,"Protect 3",
	PROTECTIONTIME,"Protect 2", WTW,"Wall-Walk"
	};

botside()
	{
	register int i,idx;
	for (i=0; i<17; i++)
		{
		idx = bot_data[i].typ;
		if ((always) || (c[idx] != cbak[idx]))
		   {
		   if ((always) || (cbak[idx] == 0))
				{ if (c[idx]) { cursor(70,i+1); lprcat(bot_data[i].string); } }  else
		   if (c[idx]==0)     { cursor(70,i+1); lprcat("          "); }
		   cbak[idx]=c[idx];
		   }
		}
	always=0;
	}

static botsub(idx,str)
	register int idx;
	char *str;
	{
	register int x,y;
	y = idx & 0xff;		x = (idx>>8) & 0xff;	  idx >>= 16;
	if (c[idx] != cbak[idx])
		{ cbak[idx]=c[idx];  cursor(x,y);  lprintf(str,(long)c[idx]); }
	}

/*
 *	subroutine to draw only a section of the screen
 *	only the top section of the screen is updated.  If entire lines are being
 *	drawn, then they will be cleared first.
 */
int d_xmin=0,d_xmax=MAXX,d_ymin=0,d_ymax=MAXY;	/* for limited screen drawing */
draws(xmin,xmax,ymin,ymax)
	int xmin,xmax,ymin,ymax;
	{
	register int i,idx;
	if (xmin==0 && xmax==MAXX) /* clear section of screen as needed */
		{
		if (ymin==0) cl_up(79,ymax);
		else for (i=ymin; i<ymin; i++)  cl_line(1,i+1);
		xmin = -1;
		}
	d_xmin=xmin;	d_xmax=xmax;	d_ymin=ymin;	d_ymax=ymax;	/* for limited screen drawing */
	drawscreen();
	if (xmin<=0 && xmax==MAXX) /* draw stuff on right side of screen as needed*/
		{
		for (i=ymin; i<ymax; i++)
			{
			idx = bot_data[i].typ;
			if (c[idx])
				{
				cursor(70,i+1); lprcat(bot_data[i].string);
				}
			cbak[idx]=c[idx];
			}
		}
	}

/*
	drawscreen()

	subroutine to redraw the whole screen as the player knows it
 */
char screen[MAXX][MAXY],d_flag;	/* template for the screen */
drawscreen()
	{
	register int i,j,k;
	int lastx,lasty;  /* variables used to optimize the object printing */
	if (d_xmin==0 && d_xmax==MAXX && d_ymin==0 && d_ymax==MAXY)
		{
		d_flag=1;  clear(); /* clear the screen */
		}
	else 
		{
		d_flag=0;  cursor(1,1);
		}
	if (d_xmin<0)
		d_xmin=0; /* d_xmin=-1 means display all without bottomline */

	for (i=d_ymin; i<d_ymax; i++)
	  for (j=d_xmin; j<d_xmax; j++)
		if (know[j][i]==0)  screen[j][i] = ' ';  else
		if (k=mitem[j][i])  screen[j][i] = monstnamelist[k];  else
		if ((k=item[j][i])==OWALL) screen[j][i] = '#';
		else screen[j][i] = ' ';

	for (i=d_ymin; i<d_ymax; i++)
		{
		j=d_xmin;  while ((screen[j][i]==' ') && (j<d_xmax)) j++;
		/* was m=0 */
		if (j >= d_xmax)  m=d_xmin; /* don't search backwards if blank line */
		else
			{	/* search backwards for end of line */
			m=d_xmax-1;  while ((screen[m][i]==' ') && (m>d_xmin)) --m;
			if (j<=m)  cursor(j+1,i+1);  else continue;
			}
		while (j <= m)
			{
			if (j <= m-3) 
				{
				for (k=j; k<=j+3; k++) if (screen[k][i] != ' ') k=1000;
				if (k < 1000)
					{ while(screen[j][i]==' ' && j<=m) j++;  cursor(j+1,i+1); }
				}
			lprc(screen[j++][i]);
			}
		}
	setbold();		/* print out only bold objects now */

	for (lastx=lasty=127, i=d_ymin; i<d_ymax; i++)
		for (j=d_xmin; j<d_xmax; j++)
			{
			if (k=item[j][i])
				if (k != OWALL)
					if ((know[j][i]) && (mitem[j][i]==0))
						if (objnamelist[k]!=' ')
							{
							if (lasty!=i+1 || lastx!=j)
								cursor(lastx=j+1,lasty=i+1); else lastx++;
							lprc(objnamelist[k]);
							}
			}

	resetbold();  if (d_flag)  { always=1; botside(); always=1; bot_linex(); }
	oldx=99;
	d_xmin = 0 , d_xmax = MAXX , d_ymin = 0 , d_ymax = MAXY; /* for limited screen drawing */
	}

/*
	showcell(x,y)

	subroutine to display a cell location on the screen
 */
showcell(x,y)
	int x,y;
	{
	register int i,j,k,m;
	if (c[BLINDCOUNT])  return;	/* see nothing if blind		*/
	if (c[AWARENESS]) { minx = x-3;	maxx = x+3;	miny = y-3;	maxy = y+3; }
			else	  { minx = x-1;	maxx = x+1;	miny = y-1;	maxy = y+1; }

	if (minx < 0) minx=0;		if (maxx > MAXX-1) maxx = MAXX-1;
	if (miny < 0) miny=0;		if (maxy > MAXY-1) maxy = MAXY-1;

	for (j=miny; j<=maxy; j++)
	  for (m=minx; m<=maxx; m++)
		if (know[m][j]==0)
			{
			cursor(m+1,j+1);
			x=maxx;  while (know[x][j]) --x;
			for (i=m; i<=x; i++)
				{
				if ((k=mitem[i][j]) != 0)  lprc(monstnamelist[k]);
				else switch(k=item[i][j])
					{
					case OWALL:  case 0: case OIVTELETRAP:  case OTRAPARROWIV:
					case OIVDARTRAP: case OIVTRAPDOOR:	
						lprc(objnamelist[k]);	break;

					default: setbold(); lprc(objnamelist[k]); resetbold();
					};
				know[i][j]=1;
				}
			m = maxx;
			}
	}

/*
	this routine shows only the spot that is given it.  the spaces around
	these coordinated are not shown
	used in godirect() in monster.c for missile weapons display
 */
show1cell(x,y)
	int x,y;
	{
	if (c[BLINDCOUNT])  return;	/* see nothing if blind		*/
	cursor(x+1,y+1);
	if ((k=mitem[x][y]) != 0)  lprc(monstnamelist[k]);
		else switch(k=item[x][y])
			{
			case OWALL:  case 0:  case OIVTELETRAP:  case OTRAPARROWIV: 
			case OIVDARTRAP: case OIVTRAPDOOR:	
				lprc(objnamelist[k]);	break;

			default: setbold(); lprc(objnamelist[k]); resetbold();
			};
	know[x][y]|=1;	/* we end up knowing about it */
	}

/*
	showplayer()

	subroutine to show where the player is on the screen
	cursor values start from 1 up
 */
showplayer()
	{
	cursor(playerx+1,playery+1);
	oldx=playerx;  oldy=playery;
	}

/*
	moveplayer(dir)

	subroutine to move the player from one room to another
	returns 0 if can't move in that direction or hit a monster or on an object
	else returns 1
	nomove is set to 1 to stop the next move (inadvertent monsters hitting
	players when walking into walls) if player walks off screen or into wall
 */
short diroffx[] = { 0,  0, 1,  0, -1,  1, -1, 1, -1 };
short diroffy[] = { 0,  1, 0, -1,  0, -1, -1, 1,  1 };
moveplayer(dir)
	int dir;			/*	from = present room #  direction = [1-north]
							[2-east] [3-south] [4-west] [5-northeast]
							[6-northwest] [7-southeast] [8-southwest]
						if direction=0, don't move--just show where he is */
	{
	register int k,m,i,j;
	if (c[CONFUSE]) if (c[LEVEL]<rnd(30)) dir=rund(9); /*if confused any dir*/
	k = playerx + diroffx[dir];		m = playery + diroffy[dir];
	if (k<0 || k>=MAXX || m<0 || m>=MAXY) { nomove=1; return(yrepcount = 0); }
	i = item[k][m];			j = mitem[k][m];
	if (i==OWALL && c[WTW]==0) { nomove=1;  return(yrepcount = 0); }		/*	hit a wall	*/
	if (k==33 && m==MAXY-1 && level==1)
		{
		newcavelevel(0); for (k=0; k<MAXX; k++) for (m=0; m<MAXY; m++)
		if (item[k][m]==OENTRANCE)
		  { playerx=k; playery=m; positionplayer();  drawscreen(); return(0); }
		}
	if (j>0)     { hitmonster(k,m);	return(yrepcount = 0); } /* hit a monster*/
	lastpx = playerx;			lastpy = playery;
	playerx = k;		playery = m;
	if (i && i!=OTRAPARROWIV && i!=OIVTELETRAP && i!=OIVDARTRAP && i!=OIVTRAPDOOR) return(yrepcount = 0);  else return(1);
	}

/*
 *	function to show what magic items have been discovered thus far
 *	enter with -1 for just spells, anything else will give scrolls & potions
 */
static int lincount,count;
seemagic(arg)
	int arg;
	{
	register int i,number;
	count = lincount = 0;  nosignal=1;

	if (arg== -1) /* if display spells while casting one */
		{
		for (number=i=0; i<SPNUM; i++) if (spelknow[i]) number++;
		number = (number+2)/3 + 4;	/* # lines needed to display */
		cl_up(79,number);  cursor(1,1);
		}
	else
		{
		resetscroll();  clear();
		}

	lprcat("The magic spells you have discovered thus far:\n\n");
	for (i=0; i<SPNUM; i++)
		if (spelknow[i])
			{ lprintf("%s %-20s ",spelcode[i],spelname[i]);  seepage(); }

	if (arg== -1)
		{
		seepage();  more();	 nosignal=0;
		draws(0,MAXX,0,number);  return;
		}

	lincount += 3;  if (count!=0) { count=2;  seepage(); }

	lprcat("\nThe magic scrolls you have found to date are:\n\n");
	count=0;
	for (i=0; i<MAXSCROLL; i++)
		if (scrollname[i][0])
		  if (scrollname[i][1]!=' ')
			{ lprintf("%-26s",&scrollname[i][1]);  seepage(); }

	lincount += 3;  if (count!=0) { count=2;  seepage(); }

	lprcat("\nThe magic potions you have found to date are:\n\n");
	count=0;
	for (i=0; i<MAXPOTION; i++)
		if (potionname[i][0])
		  if (potionname[i][1]!=' ')
			{ lprintf("%-26s",&potionname[i][1]);  seepage(); }

	if (lincount!=0) more();	nosignal=0;  setscroll();	drawscreen();
	}

/*
 *	subroutine to paginate the seemagic function
 */
seepage()
	{
	if (++count==3)
		{
		lincount++;	count=0;	lprc('\n');
		if (lincount>17) {	lincount=0;  more();  clear();	}
		}
	}
SHAR_EOF
if test 11954 -ne "`wc -c < 'display.c'`"
then
	echo shar: error transmitting "'display.c'" '(should have been 11954 characters)'
fi
fi
echo shar: extracting "'global.c'" '(15478 characters)'
if test -f 'global.c'
then
	echo shar: will not over-write existing file "'global.c'"
else
cat << \SHAR_EOF > 'global.c'
/*	global.c 		Larn is copyrighted 1986 by Noah Morgan.
 *
 *	raiselevel()		subroutine to raise the player one level
 *	loselevel()		subroutine to lower the player by one level
 *	raiseexperience(x)	subroutine to increase experience points
 *	loseexperience(x)	subroutine to lose experience points
 *	losehp(x)			subroutine to remove hit points from the player
 *	losemhp(x)			subroutine to remove max # hit points from the player
 *	raisehp(x)			subroutine to gain hit points
 *	raisemhp(x)			subroutine to gain maximum hit points
 *	losespells(x)		subroutine to lose spells
 *	losemspells(x)		subroutine to lose maximum spells
 *	raisespells(x)		subroutine to gain spells
 *	raisemspells(x)		subroutine to gain maximum spells
 *	recalc()			function to recalculate the armor class of the player
 *	makemonst(lev)		function to return monster number for a randomly selected monster
 *	positionplayer()	function to be sure player is not in a wall
 *	quit()				subroutine to ask if the player really wants to quit
 */

#include "header.h"
extern int score[],srcount,dropflag;
extern int random;/*	the random number seed			*/
extern short playerx,playery,lastnum;
extern char cheat,level,monstnamelist[];
extern char lastmonst[],*what[],*who[]; 
extern char winner[];
extern char logname[],monstlevel[];
extern char sciv[SCORESIZE+1][26][2],*potionname[],*scrollname[];
/*
	***********
	RAISE LEVEL
	***********
	raiselevel()

	subroutine to raise the player one level
	uses the skill[] array to find level boundarys
	uses c[EXPERIENCE]  c[LEVEL]
 */
raiselevel()
	{
	if (c[LEVEL] < MAXPLEVEL) raiseexperience((long)(skill[c[LEVEL]]-c[EXPERIENCE]));
	}

/*
	***********
	LOOSE LEVEL
	***********
    loselevel()

	subroutine to lower the players character level by one
 */
loselevel()
	{
	if (c[LEVEL] > 1) loseexperience((long)(c[EXPERIENCE] - skill[c[LEVEL]-1] + 1));
	}

/*
	****************
	RAISE EXPERIENCE
	****************
	raiseexperience(x)

	subroutine to increase experience points
 */
raiseexperience(x)
	register long x;
	{
	register int i,tmp;
	i=c[LEVEL];	c[EXPERIENCE]+=x;
	while (c[EXPERIENCE] >= skill[c[LEVEL]] && (c[LEVEL] < MAXPLEVEL))
		{
		tmp = (c[CONSTITUTION]-c[HARDGAME])>>1;
		c[LEVEL]++;	raisemhp((int)(rnd(3)+rnd((tmp>0)?tmp:1)));
		raisemspells((int)rund(3));
		if (c[LEVEL] < 7-c[HARDGAME]) raisemhp((int)(c[CONSTITUTION]>>2));
		}
	if (c[LEVEL] != i)
		{
		cursors();
		beep(); lprintf("\nWelcome to level %d",(long)c[LEVEL]);	/* if we changed levels	*/
		}
	bottomline();
	}

/*
	****************
	LOOSE EXPERIENCE
	****************
	loseexperience(x)

	subroutine to lose experience points
 */
loseexperience(x)
	register long x;
	{
	register int i,tmp;
	i=c[LEVEL];		c[EXPERIENCE]-=x;
	if (c[EXPERIENCE] < 0) c[EXPERIENCE]=0;
	while (c[EXPERIENCE] < skill[c[LEVEL]-1])
		{
		if (--c[LEVEL] <= 1) c[LEVEL]=1;	/*	down one level		*/
		tmp = (c[CONSTITUTION]-c[HARDGAME])>>1;	/* lose hpoints */
		losemhp((int)rnd((tmp>0)?tmp:1));	/* lose hpoints */
		if (c[LEVEL] < 7-c[HARDGAME]) losemhp((int)(c[CONSTITUTION]>>2));
		losemspells((int)rund(3));				/*	lose spells		*/
		}
	if (i!=c[LEVEL])
		{
		cursors();
		beep(); lprintf("\nYou went down to level %d!",(long)c[LEVEL]);
		}
	bottomline();
	}

/*
	********
	LOOSE HP
	********
	losehp(x)
	losemhp(x)

	subroutine to remove hit points from the player
	warning -- will kill player if hp goes to zero
 */
losehp(x)
	register int x;
	{
	if ((c[HP] -= x) <= 0)
		{
		beep(); lprcat("\n");  nap(3000);  died(lastnum);
		}
	}

losemhp(x)
	register int x;
	{
	c[HP] -= x;		if (c[HP] < 1)		c[HP]=1;
	c[HPMAX] -= x;	if (c[HPMAX] < 1)	c[HPMAX]=1;
	}

/*
	********
	RAISE HP
	********
	raisehp(x)
	raisemhp(x)

	subroutine to gain maximum hit points
 */
raisehp(x)
	register int x;
	{
	if ((c[HP] += x) > c[HPMAX]) c[HP] = c[HPMAX];
	}

raisemhp(x)
	register int x;
	{
	c[HPMAX] += x;	c[HP] += x;
	}

/*
	************
	RAISE SPELLS
	************
	raisespells(x)
	raisemspells(x)

	subroutine to gain maximum spells
 */
raisespells(x)
	register int x;
	{
	if ((c[SPELLS] += x) > c[SPELLMAX])	c[SPELLS] = c[SPELLMAX];
	}

raisemspells(x)
	register int x;
	{
	c[SPELLMAX]+=x; c[SPELLS]+=x;
	}

/*
	************
	LOOSE SPELLS
	************
	losespells(x)
	losemspells(x)

	subroutine to lose maximum spells
 */
losespells(x)
	register int x;
	{
	if ((c[SPELLS] -= x) < 0) c[SPELLS]=0;
	}

losemspells(x)
	register int x;
	{
	if ((c[SPELLMAX] -= x) < 0) c[SPELLMAX]=0;
	if ((c[SPELLS] -= x) < 0) c[SPELLS]=0;
	}

/*
	makemonst(lev)
		int lev;

	function to return monster number for a randomly selected monster
		for the given cave level	
 */
makemonst(lev)
	register int lev;
	{
	register int tmp,x;
	if (lev < 1)	lev = 1;			if (lev > 12)	lev = 12;
	tmp=WATERLORD;
	if (lev < 5)
		while (tmp==WATERLORD) tmp=rnd((x=monstlevel[lev-1])?x:1);
	else while (tmp==WATERLORD)
		tmp=rnd((x=monstlevel[lev-1]-monstlevel[lev-4])?x:1)+monstlevel[lev-4];

	while (monster[tmp].genocided && tmp<MAXMONST) tmp++; /* genocided? */
	return(tmp);
	}

/*
	positionplayer()

	function to be sure player is not in a wall
 */
positionplayer()
	{
	int try;
	try = 2;
	while ((item[playerx][playery] || mitem[playerx][playery]) && (try))
		if (++playerx >= MAXX-1)
			{
			playerx = 1;
			if (++playery >= MAXY-1)
				{	playery = 1;	--try;	}
			}
	if (try==0)	 lprcat("Failure in positionplayer\n");
	}

/*
	recalc()	function to recalculate the armor class of the player
 */
recalc()
	{
	register int i,j,k;
	c[AC] = c[MOREDEFENSES];
	if (c[WEAR] >= 0)  
		switch(iven[c[WEAR]])
			{
			case OSHIELD:		c[AC] += 2 + ivenarg[c[WEAR]]; break;
			case OLEATHER:		c[AC] += 2 + ivenarg[c[WEAR]]; break;
			case OSTUDLEATHER:	c[AC] += 3 + ivenarg[c[WEAR]]; break;
			case ORING:			c[AC] += 5 + ivenarg[c[WEAR]]; break;
			case OCHAIN:		c[AC] += 6 + ivenarg[c[WEAR]]; break;
			case OSPLINT:		c[AC] += 7 + ivenarg[c[WEAR]]; break;
			case OPLATE:		c[AC] += 9 + ivenarg[c[WEAR]]; break;
			case OPLATEARMOR:	c[AC] += 10 + ivenarg[c[WEAR]]; break;
			case OSSPLATE:		c[AC] += 12 + ivenarg[c[WEAR]]; break;
			}

	if (c[SHIELD] >= 0) if (iven[c[SHIELD]] == OSHIELD) c[AC] += 2 + ivenarg[c[SHIELD]];
	if (c[WIELD] < 0)  c[WCLASS] = 0;  else
		{
		i = ivenarg[c[WIELD]];
		switch(iven[c[WIELD]])
			{
			case ODAGGER:    c[WCLASS] =  3 + i;  break;
			case OBELT:	     c[WCLASS] =  7 + i;  break;
			case OSHIELD:	 c[WCLASS] =  8 + i;  break;
			case OSPEAR:     c[WCLASS] = 10 + i;  break;
			case OFLAIL:     c[WCLASS] = 14 + i;  break;
			case OBATTLEAXE: c[WCLASS] = 17 + i;  break;
			case OLANCE:	 c[WCLASS] = 19 + i;  break;
			case OLONGSWORD: c[WCLASS] = 22 + i;  break;
			case O2SWORD:    c[WCLASS] = 26 + i;  break;
			case OSWORD:     c[WCLASS] = 32 + i;  break;
			case OSWORDofSLASHING: c[WCLASS] = 30 + i; break;
			case OHAMMER:    c[WCLASS] = 35 + i;  break;
			default:	     c[WCLASS] = 0;
			}
		}
	c[WCLASS] += c[MOREDAM];

/*	now for regeneration abilities based on rings	*/
	c[REGEN]=1;		c[ENERGY]=0;
	j=0;  for (k=25; k>0; k--)  if (iven[k]) {j=k; k=0; }
	for (i=0; i<=j; i++)
		{
		switch(iven[i])
			{
			case OPROTRING: c[AC]     += ivenarg[i] + 1;	break;
			case ODAMRING:  c[WCLASS] += ivenarg[i] + 1;	break;
			case OBELT:     c[WCLASS] += ((ivenarg[i]<<1)) + 2;	break;

			case OREGENRING:	c[REGEN]  += ivenarg[i] + 1;	break;
			case ORINGOFEXTRA:	c[REGEN]  += 5 * (ivenarg[i]+1); break;
			case OENERGYRING:	c[ENERGY] += ivenarg[i] + 1;	break;
			}
		}
	}


/*
	quit()

	subroutine to ask if the player really wants to quit
 */
quit()
	{
	register int i;
	cursors();	strcpy(lastmonst,"");
	lprcat("\n\nDo you really want to quit?");
	while (1)
		{
		i=getchar();
		if (i == 'y')	{ died(300); return; }
		if ((i == 'n') || (i == '\33'))	{ lprcat(" no"); lflush(); return; }
		lprcat("\n");  setbold();  lprcat("Yes");  resetbold();  lprcat(" or ");
		setbold();  lprcat("No");  resetbold();  lprcat(" please?   Do you want to quit? ");
		}	
	}

/*
	function to ask --more-- then the user must enter a space
 */
more()
	{
	lprcat("\n  --- press ");  standout("space");  lprcat(" to continue --- ");
	while (getchar() != ' ');
	}

/*
	function to put something in the players inventory
	returns 0 if success, 1 if a failure
 */
take(itm,arg)
	int itm,arg;
	{
	register int i,limit;
/*	cursors(); */
	if ((limit = 15+(c[LEVEL]>>1)) > 26)  limit=26;
	for (i=0; i<limit; i++)
		if (iven[i]==0)
			{
			iven[i] = itm;  ivenarg[i] = arg;  limit=0;
			switch(itm)
				{
				case OPROTRING:	case ODAMRING: case OBELT: limit=1;  break;
				case ODEXRING:		c[DEXTERITY] += ivenarg[i]+1; limit=1;	break;
				case OSTRRING:		c[STREXTRA]  += ivenarg[i]+1;	limit=1; break;
				case OCLEVERRING:	c[INTELLIGENCE] += ivenarg[i]+1;  limit=1; break;
				case OHAMMER:		c[DEXTERITY] += 10;	c[STREXTRA]+=10;
									c[INTELLIGENCE]-=10;	limit=1;	 break;

				case OORBOFDRAGON:	c[SLAYING]++;		break;
				case OSPIRITSCARAB: c[NEGATESPIRIT]++;	break;
				case OCUBEofUNDEAD: c[CUBEofUNDEAD]++;	break;
				case ONOTHEFT:		c[NOTHEFT]++;		break;
				case OSWORDofSLASHING:	c[DEXTERITY] +=5;	limit=1; break;
				};
			lprcat("\nYou pick up:"); srcount=0;  show3(i);
			if (limit) bottomline();  return(0);
			}
	lprcat("\nYou can't carry anything else");  return(1);
	}

/*
	subroutine to drop an object  returns 1 if something there already else 0
 */
drop_object(k)
	int k;
	{
	int itm;
	if ((k<0) || (k>25)) return(0);
	itm = iven[k];	cursors();
	if (itm==0) { lprintf("\nYou don't have item %c! ",k+'a'); return(1); }
	if (item[playerx][playery])
		{ beep(); lprcat("\nThere's something here already"); return(1); }
	if (playery==MAXY-1 && playerx==33) return(1); /* not in entrance */
	item[playerx][playery] = itm;
	iarg[playerx][playery] = ivenarg[k];
	srcount=0; lprcat("\n  You drop:"); show3(k); /* show what item you dropped*/
	know[playerx][playery] = 0;  iven[k]=0; 
	if (c[WIELD]==k) c[WIELD]= -1;		if (c[WEAR]==k)  c[WEAR] = -1;
	if (c[SHIELD]==k) c[SHIELD]= -1;
	adjustcvalues(itm,ivenarg[k]);
	dropflag=1; /* say dropped an item so wont ask to pick it up right away */
	return(0);
	}

/*
	function to enchant armor player is currently wearing
 */
enchantarmor()
	{
	register int tmp;
	if (c[WEAR]<0) { if (c[SHIELD] < 0)
		{ cursors(); beep(); lprcat("\nYou feel a sense of loss"); return; }
					else { tmp=iven[c[SHIELD]]; if (tmp != OSCROLL) if (tmp != OPOTION) { ivenarg[c[SHIELD]]++; bottomline(); } } }
	tmp = iven[c[WEAR]];
	if (tmp!=OSCROLL) if (tmp!=OPOTION)  { ivenarg[c[WEAR]]++;  bottomline(); }
	}

/*
	function to enchant a weapon presently being wielded
 */
enchweapon()
	{
	register int tmp;
	if (c[WIELD]<0)
		{ cursors(); beep(); lprcat("\nYou feel a sense of loss"); return; }
	tmp = iven[c[WIELD]];
	if (tmp!=OSCROLL) if (tmp!=OPOTION)
		{ ivenarg[c[WIELD]]++;
		  if (tmp==OCLEVERRING) c[INTELLIGENCE]++;  else
		  if (tmp==OSTRRING)	c[STREXTRA]++;  else
		  if (tmp==ODEXRING)    c[DEXTERITY]++;		  bottomline(); }
	}

/*
	routine to tell if player can carry one more thing
	returns 1 if pockets are full, else 0
 */
pocketfull()
	{
	register int i,limit; 
	if ((limit = 15+(c[LEVEL]>>1)) > 26)  limit=26;
	for (i=0; i<limit; i++) if (iven[i]==0) return(0);
	return(1);
	}

/*
	function to return 1 if a monster is next to the player else returns 0
 */
nearbymonst()
	{
	register int tmp,tmp2;
	for (tmp=playerx-1; tmp<playerx+2; tmp++)
		for (tmp2=playery-1; tmp2<playery+2; tmp2++)
			if (mitem[tmp][tmp2]) return(1); /* if monster nearby */
	return(0);
	}

/*
	function to steal an item from the players pockets
	returns 1 if steals something else returns 0
 */
stealsomething()
	{
	register int i,j;
	j=100;
	while (1)
		{
		i=rund(26);
		if (iven[i]) if (c[WEAR]!=i) if (c[WIELD]!=i) if (c[SHIELD]!=i)
			{
			srcount=0; show3(i);
			adjustcvalues(iven[i],ivenarg[i]);  iven[i]=0; return(1);
			}
		if (--j <= 0) return(0);
		}
	}

/*
	function to return 1 is player carrys nothing else return 0
 */
emptyhanded()
	{
	register int i;
	for (i=0; i<26; i++)
		if (iven[i]) if (i!=c[WIELD]) if (i!=c[WEAR]) if (i!=c[SHIELD]) return(0);
	return(1);
	}

/*
	function to create a gem on a square near the player
 */
creategem()
	{
	register int i,j;
	switch(rnd(4))
		{
		case 1:	 i=ODIAMOND;	j=50;	break;
		case 2:	 i=ORUBY;		j=40;	break;
		case 3:	 i=OEMERALD;	j=30;	break;
		default: i=OSAPPHIRE;	j=20;	break;
		};
	createitem(i,rnd(j)+j/10);
	}

/*
	function to change character levels as needed when dropping an object
	that affects these characteristics
 */
adjustcvalues(itm,arg)
	int itm,arg;
	{
	register int flag;
	flag=0;
	switch(itm)
		{
		case ODEXRING:	c[DEXTERITY] -= arg+1;  flag=1; break;
		case OSTRRING:	c[STREXTRA]  -= arg+1;  flag=1; break;
		case OCLEVERRING: c[INTELLIGENCE] -= arg+1;  flag=1; break;
		case OHAMMER:	c[DEXTERITY] -= 10;	c[STREXTRA] -= 10;
						c[INTELLIGENCE] += 10; flag=1; break;
		case OSWORDofSLASHING:	c[DEXTERITY] -= 5;	flag=1; break;
		case OORBOFDRAGON:		--c[SLAYING];		return;
		case OSPIRITSCARAB:		--c[NEGATESPIRIT];	return;
		case OCUBEofUNDEAD:		--c[CUBEofUNDEAD];	return;
		case ONOTHEFT:			--c[NOTHEFT]; 		return;
		case OLANCE:		c[LANCEDEATH]=0;	return;
		case OPOTION:	case OSCROLL:	return;

		default:	flag=1;
		};
	if (flag) bottomline();
	}

/*
	function to read a string from token input "string"
	returns a pointer to the string
 */
gettokstr(str)
	register char *str;
	{
	register int i,j;
	i=50;
	while ((getchar() != '"') && (--i > 0));
	i=36;
	while (--i > 0)
		{
		if ((j=getchar()) != '"') *str++ = j;  else i=0;
		}
	*str = 0;
	i=50;
	if (j != '"') while ((getchar() != '"') && (--i > 0)); /* if end due to too long, then find closing quote */
	}

/*
	function to ask user for a password (no echo)
	returns 1 if entered correctly, 0 if not
 */
static char gpwbuf[33];
getpassword()
	{
	register int i,j;
	register char *gpwp;
	extern char *password;
	scbr();	/*	system("stty -echo cbreak"); */
	gpwp = gpwbuf;	lprcat("\nEnter Password: "); lflush();
	i = strlen(password);
	for (j=0; j<i; j++) read(0,gpwp++,1);	  gpwbuf[i]=0;
	sncbr(); /* system("stty echo -cbreak"); */
	if (strcmp(gpwbuf,password) != 0)
		{	lprcat("\nSorry\n");  lflush(); return(0);	}
	else  return(1);
	}

/*
	subroutine to get a yes or no response from the user
	returns y or n
 */
getyn()
	{
	register int i;
	i=0; while (i!='y' && i!='n' && i!='\33') i=getchar();
	return(i);
	}

/*
	function to calculate the pack weight of the player
	returns the number of pounds the player is carrying
 */
packweight()
	{
	register int i,j,k;
	k=c[GOLD]/1000; j=25;  while ((iven[j]==0) && (j>0)) --j;
	for (i=0; i<=j; i++)
		switch(iven[i])
			{
			case 0:												break;
			case OSSPLATE:   case OPLATEARMOR:		k += 40;	break;
			case OPLATE:							k += 35;	break;
			case OHAMMER:							k += 30;	break;
			case OSPLINT:							k += 26;	break;
			case OSWORDofSLASHING:	case OCHAIN:
			case OBATTLEAXE:   		case O2SWORD:	k += 23;	break;
			case OLONGSWORD:   		case OSWORD:
			case ORING:				case OFLAIL:	k += 20;	break;
			case OLANCE: 		case OSTUDLEATHER:	k += 15;	break;
			case OLEATHER:   		case OSPEAR:	k += 8;		break;
			case OORBOFDRAGON:   	case OBELT:		k += 4;		break;
			case OSHIELD:							k += 7;		break;
			case OCHEST:		k += 30 + ivenarg[i];			break;
			default:								k++;
			};
	return(k);
	}

#ifndef MACRORND
	/* macros to generate random numbers   1<=rnd(N)<=N   0<=rund(N)<=N-1 */
rnd(x)
	int x;
	{
	return((((randx=randx*1103515245+12345)>>7)%(x))+1);
	}

rund(x)
	int x;
	{
	return((((randx=randx*1103515245+12345)>>7)%(x))  );
	}
#endif MACRORND
SHAR_EOF
if test 15478 -ne "`wc -c < 'global.c'`"
then
	echo shar: error transmitting "'global.c'" '(should have been 15478 characters)'
fi
fi
echo shar: extracting "'nap.c'" '(2399 characters)'
if test -f 'nap.c'
then
	echo shar: will not over-write existing file "'nap.c'"
else
cat << \SHAR_EOF > 'nap.c'
/* nap.c		 Larn is copyrighted 1986 by Noah Morgan. */
#include <signal.h>
#include <sys/types.h>
#ifdef SYSV
#include <sys/times.h>
#else
#ifdef BSD
#include <sys/timeb.h>
#endif BSD
#endif SYSV

/*
 *	routine to take a nap for n milliseconds
 */
nap(x)
	register int x;
	{
	if (x<=0) return; /* eliminate chance for infinite loop */
	lflush();
	if (x > 999) sleep(x/1000); else napms(x);
	}

#ifdef NONAP
napms(x)	/* do nothing */
	int x;
	{
	}
#else NONAP
#ifdef SYSV
/*	napms - sleep for time milliseconds - uses times() */
/* this assumes that times returns a relative time in 60ths of a second */
/* this will do horrible things if your times() returns seconds! */
napms(time)
	int time;
	{
	long matchclock, times();
	struct tms stats;

	if (time<=0) time=1; /* eliminate chance for infinite loop */
	if ((matchclock = times(&stats)) == -1 || matchclock == 0)
		return;	/* error, or BSD style times() */
	matchclock += (time / 17);		/*17 ms/tic is 1000 ms/sec / 60 tics/sec */

	while(matchclock < times(&stats))
		;
	}

#else not SYSV
#ifdef BSD
#ifdef SIGVTALRM
/* This must be BSD 4.2!  */
#include <sys/time.h>
#define bit(_a) (1<<((_a)-1))

static  nullf()
    {
    }

/*	napms - sleep for time milliseconds - uses setitimer() */
napms(time)
	int time;
    {
    struct itimerval    timeout;
    int     (*oldhandler) ();
    int     oldsig;

	if (time <= 0) return;

    timerclear(&timeout.it_interval);
    timeout.it_value.tv_sec = time / 1000;
    timeout.it_value.tv_usec = (time % 1000) * 1000;

    oldsig = sigblock(bit(SIGALRM));
    setitimer(ITIMER_REAL, &timeout, (struct itimerval *)0);
    oldhandler = signal(SIGALRM, nullf);
    sigpause(oldsig);
    signal(SIGALRM, oldhandler);
    sigsetmask(oldsig);
    }

#else
/*	napms - sleep for time milliseconds - uses ftime() */

static napms(time)
	int time;
	{
	/* assumed to be BSD UNIX */
	struct timeb _gtime;
	time_t matchtime;
	unsigned short matchmilli;
	register struct timeb *tp = & _gtime;

	if (time <= 0) return;
	ftime(tp);
	matchmilli = tp->millitm + time;
	matchtime  = tp->time;
	while (matchmilli >= 1000)
		{
		++matchtime;
		matchmilli -= 1000;
		}

	while(1)
		{
		ftime(tp);
		if ((tp->time > matchtime) ||
			((tp->time == matchtime) && (tp->millitm >= matchmilli)))
			break;
		}
	}
#endif
#else not BSD
static napms(time) int time; {}	/* do nothing, forget it */
#endif BSD
#endif SYSV
#endif NONAP
SHAR_EOF
if test 2399 -ne "`wc -c < 'nap.c'`"
then
	echo shar: error transmitting "'nap.c'" '(should have been 2399 characters)'
fi
fi
exit 0
#	End of shell archive
